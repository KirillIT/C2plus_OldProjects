#include <iostream> //библиотека для ввода и вывода данных в консоль

#include <Windows.h> //библиотека для подлючения русского языка (В данном случае)

#include <fstream> //для подключения файлов

#include <string> //для использования строк

#include <sstream> //эта нужна только для 73-ей строки (переводит строку в число)

using namespace std;//эта строка позволяет писать так - "cout « ..." вместо "std::cout « ..."

int** creatArr(string path, int & M, int & N) {//функция, создаёт массив по нужному размеру (смотрит в файле). Принимает путь и размеры массива, которые мы здесь будем менять

	fstream file; //переменная файла(для работы с файлами)

	file.open(path, fstream::in); //окрываем файл, path - путь, fstream::in означает, что файл открыт только для чтения

	string helper; //строка-помощник

	while (!file.eof()) {//для начала, чтобы создать массив, мы должны узнать его размеры. Тут кзнаем кол-во строк. Пока файл не закончен, выполняем это цикл. eof = end of file

		getline(file, helper);//считываем строку из файла в строку-помощник

		M++;//и увеличиваем наш счётчик строк

	}

	for (int i = 0; i < helper.size(); i++) {//теперь узнаем кол-во столбцов. У нас в переменной helper сейчас строка из файла. Например "-2 -3 -4 -5 -6 -7"
		//соответственно, сколько у нас элеменетов в одной строке, столько у нас и столбцов, т.к. по условию матрица прямоугольная
		if (helper[i] == ' ') {//проходим по нашей строке "-2 -3 -4 -5 -6 -7" посимвольно, и если встречаем пробел,

			N++;//то увеличиваем счётчик столбцов. Замечу, что пробелов в строке - 5, а чисел 6. Именно поэтому появилась единица(см. строку 29)

		}
	}

	file.close();//закроем файл, т.к. он у нас уже закончился (условно говоря мы сейчас находимся в конце файла) и нужно будет открыть его заново, чтобы начать просмотр с первой строки

	int** mainArr = new int* [M];//создаём нашу матрицу

	for (int i = 0; i < M; i++) {

		mainArr[i] = new int[N];//это тоже её создание

	}

	return mainArr;//возвращает подготовленные для заполнения массив (в памяти он уже есть, но в нём пока что нет нужных нам значений)

}

void fromFileIntoMatrix(string path, int ** mainArr,const int M,const int N) {//записывает данные из файла в матрицу

	fstream file; //переменная файла(для работы с файлами)

	string helper; //строка-помощник

	file.open(path, fstream::in);//опять окрываем файл, path - путь, fstream::in означает, что файл открыт только для чтения

	for (int i = 0; i < M; i++) {//тут алгоритм записи данных из файла в нашу матрицу

		for (int j = 0; j < N; j++) {

			helper = "";//обнуляем строку-помощник

			file >> helper;//записываем из файла в строку-помощник 

			istringstream(helper) >> mainArr[i][j];//а эта строка конвертирует строку в число и записывает это число в массив

			cout << mainArr[i][j] << " ";//тут выводим массив в консоль

		}

		cout << endl;//когда строка закончилась, мы должны перейти на следующую. Для вывода в консоль

	}
}

void process(int** mainArr, const int M, const int N) {//тут основной алгоритм

	int startIndex = N - 2;//начинаем с предпоследнего элемента в строке. Т.к. в С++ нумерация массива идёт с нуля, то последний элемент будет с индексом N - 1, а предпоследний - N - 2

	for (int i = 1; i < M - 1; i++) {//проходимся по матрице, чтобы заменить нуждый нам элементы (кроме первой и последней строки)

		for (int j = 0; j < N; j++) {

			if (j == startIndex) {//когда номер нашего элемента равен индексу startIndex, то...

				mainArr[i][j] = mainArr[i][j - 1] + mainArr[i][j + 1];//заменяем этот элемент суммой рядом стоящих элементов

				startIndex--;//уменьшаем наш стартовый индекс

			}
		}
	}

	for (int i = 0; i < M; i++) {//тут обычный вывод матрицы в консоль

		for (int j = 0; j < N; j++) {

			cout << mainArr[i][j] << " ";

		}

		cout << endl;//когда строка закончилась, мы должны перейти на следующую. Для вывода в консоль

	}

	for (int i = 0; i < M; i++) {

		delete[] mainArr[i];//в конце программы обязательно удаляем матрицу

	}	
	
	delete[] mainArr;//это тоже удаление матрицы

}

int main() {//программа начинает работать именно отсюда, с этой главной функции

	SetConsoleCP(1251); //для подлючения русского языка

	SetConsoleOutputCP(1251); //для подлючения русского языка

	HANDLE hOUTPUT = GetStdHandle(STD_OUTPUT_HANDLE); //создание объекта, чтобы изменить цвет текущей консоли

	cout << "Введите путь к файлу: ";

	string path; //строка, хранящая путь к файлу

	SetConsoleTextAttribute(hOUTPUT, FOREGROUND_RED); //делаем красный цвет

	cin >> path; //вводим путь к файлу

	int M = 0, N = 1; //это размер нашего будущего массива, пока что присвоим M(кол-во строк) - ноль и N (кол-во столбцов) - 1. Почему тут 1, внизу поясню

	int** mainArr = creatArr(path, M, N);//создаём нашу матрицу (с помощью функции)

	SetConsoleTextAttribute(hOUTPUT, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE); //возвращаем белый цвет

	cout << "Исходная матрица из файла" << endl;

	SetConsoleTextAttribute(hOUTPUT, FOREGROUND_GREEN); //делаем зелёный цвет
	
	fromFileIntoMatrix(path, mainArr, M, N); //запишем данные из файла в матрицу

	SetConsoleTextAttribute(hOUTPUT, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE); //возвращаем белый цвет

	cout << endl << "Матрица после преобразований" << endl;

	SetConsoleTextAttribute(hOUTPUT, FOREGROUND_BLUE); //делаем синий цвет

	process(mainArr, M, N);//вызовем основной алгоритм

	SetConsoleTextAttribute(hOUTPUT, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE); //возвращаем белый цвет

}